При фазз тестировании использовался libFuzzer.

LibFuzzer очень прост в установке на UNIX, поскольку встроен в Clang + llvm.

Для работы с libFuzzer'ом, нужно создать специальную функцию 

```
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
  DoSomethingInterestingWithMyAPI(Data, Size);
  return 0;  // Values other than 0 and -1 are reserved for future use.
}
````

где DoSomethingInterestingWithMyAPI -- будет тестируемой функцией.
Аргументы Data и Size -- буфер с фиксированным размером, который будет обработан программой.


--------------Использование в проекте

Одним из плюсов libFuzzera -- можно легко и быстро интегрировать в проект и начать работать.

Например, я "профаззил" свой студенческий проект (в котором уже были unit тесты), написанный на С++, в котором около 5000 строк кода. Вот что получилось:

1. Поскольку материала не так много практического в интернете, то создавал отдельно программу для тестирования отдельной функции.
2. "Собирал фаззер" с рандомными сидамии и параметрами, такие как -fsanitize=fuzzer,address (есть еще параметр memory, но его нельзя использовать с address).
3. Запускал фаззер. Фазер либо создавал тест-кейс который прерывал программу, либо исполнялся до определенного условия, указанного при старте (например, указать
количество прогонов с помощью опции runs).
4. В случае ошибки, фазер выдавал stack trace, тип ошибки и дополнительную информацию, которую нужно научиться еще читать.
5. Также libFuzzer при ошибке создает тест-кейс соответствующий.

За весь процесс фаззинга в моем проекте обнаружилось более 100 уязвимостей, и самая часто встречающеся ошибки были AddressSanitizer: heap-buffer-overflow
(например, при создании строки из char*, при работе с массивами...) и LeakSanitizer. Где-то не освободил указатель, где-то строка создается криво. 
Одна из самых интересных вещей, что подобные ошибки заставляют создавать более безопасный код.


Но не все выходило так гладко, и вот некоторые вещи, с которыми нужно еще разобраться

1. Создавать собственные сиды. Фаззер может работать с некоторыми входными сидами (верными и неверными шаблонами), что повысить эффективность тестирования.
Надо разобраться, как создавать собственные сиды.
2. Разобраться с чтением ошибки, а именно со следующим выводом фазера, как его правильно читать:

Shadow bytes around the buggy address:
  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x0c047fff8350: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x0c047fff8360: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x0c047fff8370: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
=>0x0c047fff8380: fa fa fd fa fa fa[05]fa fa fa fa fa fa fa fa fa
  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff83d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  
3. Найти примеры, как используют в других проектах подобный фаззер, поскольку встречаются в основном детские примеры на 20 строк кода и c примитивными типами. 
4. Интересно, как работают другие фазеры. Выяснилось, что этот фазер и AFL работают в разных ситуациях лучше/хуже
5. Вопрос как корректно организовать фаззер-тестирование. Например, я создавал файл для тестирование отдельного участка кода, и запускал каждый по отдельности.
-----------------------------------------

В целом, фаззинг выглядит как must have для проектов на первый взгляд (особенно C\C++). На мой взглядт он дает ваюное при тестировании, а именно
создает "широкую" область определения для определеннного участка кода, которую программист не в состоянии покрыть. Основное время
при изучении фазз-тестирования ушло на исправление ошибок в коде, изучении опций запуска фазера, а также поиск материала по libFuzzer'у. Разобрался как проводить
тестирование, но теперь нужно понять, как указал выше, как правильно организовать тестирование, поскольку есть полно теоретического материала (лекции, конференции), 
но практического примера не особо.


По поводу libfuzzer'a могу сказать, что для первого фаззинга это самое то, поскольку требует только clanga, и легко подобное внедрить в CI/CD. 


P.S.
Крутой материал: https://www.moritz.systems/blog/an-introduction-to-llvm-libfuzzer/
